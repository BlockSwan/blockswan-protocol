{
  "address": "0x98a5eA2D890197043Ab890082ABDf3402c50E0d9",
  "abi": [],
  "transactionHash": "0xe049cd656524e4dc2a6442982497fdfb4d6e61f39fd2d669d6231269eee0c20c",
  "receipt": {
    "to": null,
    "from": "0x8D3BD47c94b340E0151376ABF9D76C74c471E213",
    "contractAddress": "0x98a5eA2D890197043Ab890082ABDf3402c50E0d9",
    "transactionIndex": 0,
    "gasUsed": "622427",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000002000000000000000000000000000000000000000000000000000800000000800000000040100000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000040000000004000000000000000000001000000000000000000000000000000100000000000000000000000100000000000000080000000000000000000000000000000100000",
    "blockHash": "0xfef595313cfe2dcdd501441f90f3a1d11ffa1c49cf3664774c9a912f96434d6b",
    "transactionHash": "0xe049cd656524e4dc2a6442982497fdfb4d6e61f39fd2d669d6231269eee0c20c",
    "logs": [
      {
        "transactionIndex": 0,
        "blockNumber": 32900039,
        "transactionHash": "0xe049cd656524e4dc2a6442982497fdfb4d6e61f39fd2d669d6231269eee0c20c",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x0000000000000000000000008d3bd47c94b340e0151376abf9d76c74c471e213",
          "0x000000000000000000000000c275dc8be39f50d12f66b6a63629c39da5bae5bd"
        ],
        "data": "0x00000000000000000000000000000000000000000000000002c39e194a298a50000000000000000000000000000000000000000000000001e7323479c103b0c7000000000000000000000000000000000000000000000e4ec0352ee3f298aeb8000000000000000000000000000000000000000000000001e46e966076da2677000000000000000000000000000000000000000000000e4ec2f8ccfd3cc23908",
        "logIndex": 0,
        "blockHash": "0xfef595313cfe2dcdd501441f90f3a1d11ffa1c49cf3664774c9a912f96434d6b"
      }
    ],
    "blockNumber": 32900039,
    "cumulativeGasUsed": "622427",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "540ab05e3117b642ab74c32eb85f094d",
  "metadata": "{\"compiler\":{\"version\":\"0.8.0+commit.c7dfd78e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"details\":\"A factory of trees that keeps track of staked values for sortition. This is the updated version for 0.8 compiler.\",\"kind\":\"dev\",\"methods\":{\"createTree(SortitionSumTreeFactory.SortitionSumTrees storage,bytes32,uint256)\":{\"details\":\"Create a sortition sum tree at the specified key.\",\"params\":{\"_K\":\"The number of children each node in the tree should have.\",\"_key\":\"The key of the new tree.\"}},\"queryLeafs(SortitionSumTreeFactory.SortitionSumTrees storage,bytes32,uint256,uint256)\":{\"details\":\"Query the leaves of a tree. Note that if `startIndex == 0`, the tree is empty and the root node will be returned.\",\"params\":{\"_count\":\"The number of items to return.\",\"_cursor\":\"The pagination cursor.\",\"_key\":\"The key of the tree to get the leaves from.\"},\"returns\":{\"hasMore\":\"Whether there are more for pagination.  `O(n)` where  `n` is the maximum number of nodes ever appended.\",\"startIndex\":\"The index at which leaves start.\",\"values\":\"The values of the returned leaves.\"}},\"set(SortitionSumTreeFactory.SortitionSumTrees storage,bytes32,uint256,bytes32)\":{\"details\":\"Set a value of a tree.\",\"params\":{\"_ID\":\"The ID of the value.  `O(log_k(n))` where  `k` is the maximum number of childs per node in the tree,   and `n` is the maximum number of nodes ever appended.\",\"_key\":\"The key of the tree.\",\"_value\":\"The new value.\"}},\"stakeOf(SortitionSumTreeFactory.SortitionSumTrees storage,bytes32,bytes32)\":{\"details\":\"Gets a specified ID's associated value.\",\"params\":{\"_ID\":\"The ID of the value.\",\"_key\":\"The key of the tree.\"},\"returns\":{\"value\":\"The associated value.\"}}},\"title\":\"SortitionSumTreeFactory\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/imports/kleros/contracts/SortitionSumTreeFactory.sol\":\"SortitionSumTreeFactory\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/imports/kleros/contracts/SortitionSumTreeFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n/**\\n *  @authors: [@epiqueras, @unknownunknown1]\\n *  @reviewers: []\\n *  @auditors: []\\n *  @bounties: []\\n *  @deployments: []\\n */\\n\\npragma solidity ^0.8;\\n\\n/**\\n *  @title SortitionSumTreeFactory\\n *  @dev A factory of trees that keeps track of staked values for sortition. This is the updated version for 0.8 compiler.\\n */\\nlibrary SortitionSumTreeFactory {\\n    /* Structs */\\n\\n    struct SortitionSumTree {\\n        uint256 K; // The maximum number of childs per node.\\n        // We use this to keep track of vacant positions in the tree after removing a leaf. This is for keeping the tree as balanced as possible without spending gas on moving nodes around.\\n        uint256[] stack;\\n        uint256[] nodes;\\n        // Two-way mapping of IDs to node indexes. Note that node index 0 is reserved for the root node, and means the ID does not have a node.\\n        mapping(bytes32 => uint256) IDsToNodeIndexes;\\n        mapping(uint256 => bytes32) nodeIndexesToIDs;\\n    }\\n\\n    /* Storage */\\n\\n    struct SortitionSumTrees {\\n        mapping(bytes32 => SortitionSumTree) sortitionSumTrees;\\n    }\\n\\n    /* Public */\\n\\n    /**\\n     *  @dev Create a sortition sum tree at the specified key.\\n     *  @param _key The key of the new tree.\\n     *  @param _K The number of children each node in the tree should have.\\n     */\\n    function createTree(\\n        SortitionSumTrees storage self,\\n        bytes32 _key,\\n        uint256 _K\\n    ) external {\\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\\n        require(tree.K == 0, \\\"Tree already exists.\\\");\\n        require(_K > 1, \\\"K must be greater than one.\\\");\\n        tree.K = _K;\\n        tree.nodes.push(0);\\n    }\\n\\n    /**\\n     *  @dev Set a value of a tree.\\n     *  @param _key The key of the tree.\\n     *  @param _value The new value.\\n     *  @param _ID The ID of the value.\\n     *  `O(log_k(n))` where\\n     *  `k` is the maximum number of childs per node in the tree,\\n     *   and `n` is the maximum number of nodes ever appended.\\n     */\\n    function set(\\n        SortitionSumTrees storage self,\\n        bytes32 _key,\\n        uint256 _value,\\n        bytes32 _ID\\n    ) external {\\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\\n        uint256 treeIndex = tree.IDsToNodeIndexes[_ID];\\n\\n        if (treeIndex == 0) {\\n            // No existing node.\\n            if (_value != 0) {\\n                // Non zero value.\\n                // Append.\\n                // Add node.\\n                if (tree.stack.length == 0) {\\n                    // No vacant spots.\\n                    // Get the index and append the value.\\n                    treeIndex = tree.nodes.length;\\n                    tree.nodes.push(_value);\\n\\n                    // Potentially append a new node and make the parent a sum node.\\n                    if (treeIndex != 1 && (treeIndex - 1) % tree.K == 0) {\\n                        // Is first child.\\n                        uint256 parentIndex = treeIndex / tree.K;\\n                        bytes32 parentID = tree.nodeIndexesToIDs[parentIndex];\\n                        uint256 newIndex = treeIndex + 1;\\n                        tree.nodes.push(tree.nodes[parentIndex]);\\n                        delete tree.nodeIndexesToIDs[parentIndex];\\n                        tree.IDsToNodeIndexes[parentID] = newIndex;\\n                        tree.nodeIndexesToIDs[newIndex] = parentID;\\n                    }\\n                } else {\\n                    // Some vacant spot.\\n                    // Pop the stack and append the value.\\n                    treeIndex = tree.stack[tree.stack.length - 1];\\n                    tree.stack.pop();\\n                    tree.nodes[treeIndex] = _value;\\n                }\\n\\n                // Add label.\\n                tree.IDsToNodeIndexes[_ID] = treeIndex;\\n                tree.nodeIndexesToIDs[treeIndex] = _ID;\\n\\n                updateParents(self, _key, treeIndex, true, _value);\\n            }\\n        } else {\\n            // Existing node.\\n            if (_value == 0) {\\n                // Zero value.\\n                // Remove.\\n                // Remember value and set to 0.\\n                uint256 value = tree.nodes[treeIndex];\\n                tree.nodes[treeIndex] = 0;\\n\\n                // Push to stack.\\n                tree.stack.push(treeIndex);\\n\\n                // Clear label.\\n                delete tree.IDsToNodeIndexes[_ID];\\n                delete tree.nodeIndexesToIDs[treeIndex];\\n\\n                updateParents(self, _key, treeIndex, false, value);\\n            } else if (_value != tree.nodes[treeIndex]) {\\n                // New, non zero value.\\n                // Set.\\n                bool plusOrMinus = tree.nodes[treeIndex] <= _value;\\n                uint256 plusOrMinusValue = plusOrMinus\\n                    ? _value - tree.nodes[treeIndex]\\n                    : tree.nodes[treeIndex] - _value;\\n                tree.nodes[treeIndex] = _value;\\n\\n                updateParents(self, _key, treeIndex, plusOrMinus, plusOrMinusValue);\\n            }\\n        }\\n    }\\n\\n    /* Public Views */\\n\\n    /**\\n     *  @dev Query the leaves of a tree. Note that if `startIndex == 0`, the tree is empty and the root node will be returned.\\n     *  @param _key The key of the tree to get the leaves from.\\n     *  @param _cursor The pagination cursor.\\n     *  @param _count The number of items to return.\\n     *  @return startIndex The index at which leaves start.\\n     *  @return values The values of the returned leaves.\\n     *  @return hasMore Whether there are more for pagination.\\n     *  `O(n)` where\\n     *  `n` is the maximum number of nodes ever appended.\\n     */\\n    function queryLeafs(\\n        SortitionSumTrees storage self,\\n        bytes32 _key,\\n        uint256 _cursor,\\n        uint256 _count\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 startIndex,\\n            uint256[] memory values,\\n            bool hasMore\\n        )\\n    {\\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\\n\\n        // Find the start index.\\n        for (uint256 i = 0; i < tree.nodes.length; i++) {\\n            if ((tree.K * i) + 1 >= tree.nodes.length) {\\n                startIndex = i;\\n                break;\\n            }\\n        }\\n\\n        // Get the values.\\n        uint256 loopStartIndex = startIndex + _cursor;\\n        values = new uint256[](\\n            loopStartIndex + _count > tree.nodes.length ? tree.nodes.length - loopStartIndex : _count\\n        );\\n        uint256 valuesIndex = 0;\\n        for (uint256 j = loopStartIndex; j < tree.nodes.length; j++) {\\n            if (valuesIndex < _count) {\\n                values[valuesIndex] = tree.nodes[j];\\n                valuesIndex++;\\n            } else {\\n                hasMore = true;\\n                break;\\n            }\\n        }\\n    }\\n\\n    function draw(SortitionSumTrees storage self, bytes32 _key, uint _drawnNumber) internal view returns(bytes32 ID) {\\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\\n        uint treeIndex = 0;\\n        uint currentDrawnNumber = _drawnNumber % tree.nodes[0];\\n\\n        while ((tree.K * treeIndex) + 1 < tree.nodes.length)  // While it still has children.\\n            for (uint i = 1; i <= tree.K; i++) { // Loop over children.\\n                uint nodeIndex = (tree.K * treeIndex) + i;\\n                uint nodeValue = tree.nodes[nodeIndex];\\n\\n                if (currentDrawnNumber >= nodeValue) currentDrawnNumber -= nodeValue; // Go to the next child.\\n                else { // Pick this child.\\n                    treeIndex = nodeIndex;\\n                    break;\\n                }\\n            }\\n        \\n        ID = tree.nodeIndexesToIDs[treeIndex];\\n    }\\n\\n    function total(SortitionSumTrees storage self, bytes32 _key) internal view returns (uint) {\\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\\n        if (tree.nodes.length == 0) {\\n            return 0;\\n        } else {\\n            return tree.nodes[0];\\n        }\\n    }\\n\\n\\n    /** @dev Gets a specified ID's associated value.\\n     *  @param _key The key of the tree.\\n     *  @param _ID The ID of the value.\\n     *  @return value The associated value.\\n     */\\n    function stakeOf(\\n        SortitionSumTrees storage self,\\n        bytes32 _key,\\n        bytes32 _ID\\n    ) external view returns (uint256 value) {\\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\\n        uint256 treeIndex = tree.IDsToNodeIndexes[_ID];\\n\\n        if (treeIndex == 0) value = 0;\\n        else value = tree.nodes[treeIndex];\\n    }\\n\\n    /* Private */\\n\\n    /**\\n     *  @dev Update all the parents of a node.\\n     *  @param _key The key of the tree to update.\\n     *  @param _treeIndex The index of the node to start from.\\n     *  @param _plusOrMinus Whether to add (true) or substract (false).\\n     *  @param _value The value to add or substract.\\n     *  `O(log_k(n))` where\\n     *  `k` is the maximum number of childs per node in the tree,\\n     *   and `n` is the maximum number of nodes ever appended.\\n     */\\n    function updateParents(\\n        SortitionSumTrees storage self,\\n        bytes32 _key,\\n        uint256 _treeIndex,\\n        bool _plusOrMinus,\\n        uint256 _value\\n    ) private {\\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\\n\\n        uint256 parentIndex = _treeIndex;\\n        while (parentIndex != 0) {\\n            parentIndex = (parentIndex - 1) / tree.K;\\n            tree.nodes[parentIndex] = _plusOrMinus\\n                ? tree.nodes[parentIndex] + _value\\n                : tree.nodes[parentIndex] - _value;\\n        }\\n    }\\n}\",\"keccak256\":\"0xbbee78df1db771d41161ac6e39d43d3a36ae69ce13ceee2b6e32e78007ffdb3a\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x610a4e61003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106100565760003560e01c80632e25c38a1461005b57806365b81f4f1461007d5780637521ccb1146100a85780639075789e146100c8575b600080fd5b81801561006757600080fd5b5061007b61007636600461084f565b6100e8565b005b61009061008b366004610880565b6104d0565b60405161009f93929190610903565b60405180910390f35b6100bb6100b6366004610824565b610665565b60405161009f91906108fa565b8180156100d457600080fd5b5061007b6100e3366004610824565b6106c9565b6000838152602085815260408083208484526003810190925290912054806102e65783156102e157600182015461020957506002810180546001808201835560009283526020909220810185905590811480159061015a5750815461014e6001836109a6565b61015891906109d8565b155b1561020457815460009061016e9083610973565b600081815260048501602052604081205491925061018d84600161095b565b9050846002018560020184815481106101b657634e487b7160e01b600052603260045260246000fd5b60009182526020808320909101548354600181018555938352818320909301929092559384526004860180825260408086208690558486526003880183528086208490559285529052909120555b6102ae565b60018083018054909161021b916109a6565b8154811061023957634e487b7160e01b600052603260045260246000fd5b906000526020600020015490508160010180548061026757634e487b7160e01b600052603160045260246000fd5b60019003818190600052602060002001600090559055838260020182815481106102a157634e487b7160e01b600052603260045260246000fd5b6000918252602090912001555b600083815260038301602090815260408083208490558383526004850190915290208390556102e186868360018861073c565b6104c8565b8361039f57600082600201828154811061031057634e487b7160e01b600052603260045260246000fd5b90600052602060002001549050600083600201838154811061034257634e487b7160e01b600052603260045260246000fd5b6000918252602080832090910192909255600180860180549182018155825282822001849055858152600385018252604080822082905584825260048601909252908120819055610399908890889085908561073c565b506104c8565b8160020181815481106103c257634e487b7160e01b600052603260045260246000fd5b906000526020600020015484146104c8576000848360020183815481106103f957634e487b7160e01b600052603260045260246000fd5b90600052602060002001541115905060008161044d578584600201848154811061043357634e487b7160e01b600052603260045260246000fd5b906000526020600020015461044891906109a6565b610486565b83600201838154811061047057634e487b7160e01b600052603260045260246000fd5b90600052602060002001548661048691906109a6565b9050858460020184815481106104ac57634e487b7160e01b600052603260045260246000fd5b6000918252602090912001556104c5888885858561073c565b50505b505050505050565b60008381526020859052604081206060908290815b600282015481101561052d5760028201548254610503908390610987565b61050e90600161095b565b1061051b5780945061052d565b80610525816109bd565b9150506104e5565b50600061053a878661095b565b600283015490915061054c878361095b565b116105575785610567565b60028201546105679082906109a6565b67ffffffffffffffff81111561058d57634e487b7160e01b600052604160045260246000fd5b6040519080825280602002602001820160405280156105b6578160200160208202803683370190505b5093506000815b6002840154811015610657578782101561063c578360020181815481106105f457634e487b7160e01b600052603260045260246000fd5b906000526020600020015486838151811061061f57634e487b7160e01b600052603260045260246000fd5b602090810291909101015281610634816109bd565b925050610645565b60019450610657565b8061064f816109bd565b9150506105bd565b505050509450945094915050565b600082815260208481526040808320848452600381019092528220548061068f57600092506106c0565b8160020181815481106106b257634e487b7160e01b600052603260045260246000fd5b906000526020600020015492505b50509392505050565b60008281526020849052604090208054156106ff5760405162461bcd60e51b81526004016106f6906108cc565b60405180910390fd5b6001821161071f5760405162461bcd60e51b81526004016106f690610895565b908155600201805460018101825560009182526020822001555050565b6000848152602086905260409020835b801561081b57815461075f6001836109a6565b6107699190610973565b9050836107ae578282600201828154811061079457634e487b7160e01b600052603260045260246000fd5b90600052602060002001546107a991906109a6565b6107e7565b828260020182815481106107d257634e487b7160e01b600052603260045260246000fd5b90600052602060002001546107e7919061095b565b82600201828154811061080a57634e487b7160e01b600052603260045260246000fd5b60009182526020909120015561074c565b50505050505050565b600080600060608486031215610838578283fd5b505081359360208301359350604090920135919050565b60008060008060808587031215610864578081fd5b5050823594602084013594506040840135936060013592509050565b60008060008060808587031215610864578384fd5b6020808252601b908201527f4b206d7573742062652067726561746572207468616e206f6e652e0000000000604082015260600190565b6020808252601490820152732a3932b29030b63932b0b23c9032bc34b9ba399760611b604082015260600190565b90815260200190565b60006060820185835260206060818501528186518084526080860191508288019350845b8181101561094357845183529383019391830191600101610927565b50508093505050508215156040830152949350505050565b6000821982111561096e5761096e6109ec565b500190565b60008261098257610982610a02565b500490565b60008160001904831182151516156109a1576109a16109ec565b500290565b6000828210156109b8576109b86109ec565b500390565b60006000198214156109d1576109d16109ec565b5060010190565b6000826109e7576109e7610a02565b500690565b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052601260045260246000fdfea2646970667358221220f67883ca10eb44fda4568a7910cbedb66cf583ff31e410742835b97505b70eea64736f6c63430008000033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600436106100565760003560e01c80632e25c38a1461005b57806365b81f4f1461007d5780637521ccb1146100a85780639075789e146100c8575b600080fd5b81801561006757600080fd5b5061007b61007636600461084f565b6100e8565b005b61009061008b366004610880565b6104d0565b60405161009f93929190610903565b60405180910390f35b6100bb6100b6366004610824565b610665565b60405161009f91906108fa565b8180156100d457600080fd5b5061007b6100e3366004610824565b6106c9565b6000838152602085815260408083208484526003810190925290912054806102e65783156102e157600182015461020957506002810180546001808201835560009283526020909220810185905590811480159061015a5750815461014e6001836109a6565b61015891906109d8565b155b1561020457815460009061016e9083610973565b600081815260048501602052604081205491925061018d84600161095b565b9050846002018560020184815481106101b657634e487b7160e01b600052603260045260246000fd5b60009182526020808320909101548354600181018555938352818320909301929092559384526004860180825260408086208690558486526003880183528086208490559285529052909120555b6102ae565b60018083018054909161021b916109a6565b8154811061023957634e487b7160e01b600052603260045260246000fd5b906000526020600020015490508160010180548061026757634e487b7160e01b600052603160045260246000fd5b60019003818190600052602060002001600090559055838260020182815481106102a157634e487b7160e01b600052603260045260246000fd5b6000918252602090912001555b600083815260038301602090815260408083208490558383526004850190915290208390556102e186868360018861073c565b6104c8565b8361039f57600082600201828154811061031057634e487b7160e01b600052603260045260246000fd5b90600052602060002001549050600083600201838154811061034257634e487b7160e01b600052603260045260246000fd5b6000918252602080832090910192909255600180860180549182018155825282822001849055858152600385018252604080822082905584825260048601909252908120819055610399908890889085908561073c565b506104c8565b8160020181815481106103c257634e487b7160e01b600052603260045260246000fd5b906000526020600020015484146104c8576000848360020183815481106103f957634e487b7160e01b600052603260045260246000fd5b90600052602060002001541115905060008161044d578584600201848154811061043357634e487b7160e01b600052603260045260246000fd5b906000526020600020015461044891906109a6565b610486565b83600201838154811061047057634e487b7160e01b600052603260045260246000fd5b90600052602060002001548661048691906109a6565b9050858460020184815481106104ac57634e487b7160e01b600052603260045260246000fd5b6000918252602090912001556104c5888885858561073c565b50505b505050505050565b60008381526020859052604081206060908290815b600282015481101561052d5760028201548254610503908390610987565b61050e90600161095b565b1061051b5780945061052d565b80610525816109bd565b9150506104e5565b50600061053a878661095b565b600283015490915061054c878361095b565b116105575785610567565b60028201546105679082906109a6565b67ffffffffffffffff81111561058d57634e487b7160e01b600052604160045260246000fd5b6040519080825280602002602001820160405280156105b6578160200160208202803683370190505b5093506000815b6002840154811015610657578782101561063c578360020181815481106105f457634e487b7160e01b600052603260045260246000fd5b906000526020600020015486838151811061061f57634e487b7160e01b600052603260045260246000fd5b602090810291909101015281610634816109bd565b925050610645565b60019450610657565b8061064f816109bd565b9150506105bd565b505050509450945094915050565b600082815260208481526040808320848452600381019092528220548061068f57600092506106c0565b8160020181815481106106b257634e487b7160e01b600052603260045260246000fd5b906000526020600020015492505b50509392505050565b60008281526020849052604090208054156106ff5760405162461bcd60e51b81526004016106f6906108cc565b60405180910390fd5b6001821161071f5760405162461bcd60e51b81526004016106f690610895565b908155600201805460018101825560009182526020822001555050565b6000848152602086905260409020835b801561081b57815461075f6001836109a6565b6107699190610973565b9050836107ae578282600201828154811061079457634e487b7160e01b600052603260045260246000fd5b90600052602060002001546107a991906109a6565b6107e7565b828260020182815481106107d257634e487b7160e01b600052603260045260246000fd5b90600052602060002001546107e7919061095b565b82600201828154811061080a57634e487b7160e01b600052603260045260246000fd5b60009182526020909120015561074c565b50505050505050565b600080600060608486031215610838578283fd5b505081359360208301359350604090920135919050565b60008060008060808587031215610864578081fd5b5050823594602084013594506040840135936060013592509050565b60008060008060808587031215610864578384fd5b6020808252601b908201527f4b206d7573742062652067726561746572207468616e206f6e652e0000000000604082015260600190565b6020808252601490820152732a3932b29030b63932b0b23c9032bc34b9ba399760611b604082015260600190565b90815260200190565b60006060820185835260206060818501528186518084526080860191508288019350845b8181101561094357845183529383019391830191600101610927565b50508093505050508215156040830152949350505050565b6000821982111561096e5761096e6109ec565b500190565b60008261098257610982610a02565b500490565b60008160001904831182151516156109a1576109a16109ec565b500290565b6000828210156109b8576109b86109ec565b500390565b60006000198214156109d1576109d16109ec565b5060010190565b6000826109e7576109e7610a02565b500690565b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052601260045260246000fdfea2646970667358221220f67883ca10eb44fda4568a7910cbedb66cf583ff31e410742835b97505b70eea64736f6c63430008000033",
  "devdoc": {
    "details": "A factory of trees that keeps track of staked values for sortition. This is the updated version for 0.8 compiler.",
    "kind": "dev",
    "methods": {
      "createTree(SortitionSumTreeFactory.SortitionSumTrees storage,bytes32,uint256)": {
        "details": "Create a sortition sum tree at the specified key.",
        "params": {
          "_K": "The number of children each node in the tree should have.",
          "_key": "The key of the new tree."
        }
      },
      "queryLeafs(SortitionSumTreeFactory.SortitionSumTrees storage,bytes32,uint256,uint256)": {
        "details": "Query the leaves of a tree. Note that if `startIndex == 0`, the tree is empty and the root node will be returned.",
        "params": {
          "_count": "The number of items to return.",
          "_cursor": "The pagination cursor.",
          "_key": "The key of the tree to get the leaves from."
        },
        "returns": {
          "hasMore": "Whether there are more for pagination.  `O(n)` where  `n` is the maximum number of nodes ever appended.",
          "startIndex": "The index at which leaves start.",
          "values": "The values of the returned leaves."
        }
      },
      "set(SortitionSumTreeFactory.SortitionSumTrees storage,bytes32,uint256,bytes32)": {
        "details": "Set a value of a tree.",
        "params": {
          "_ID": "The ID of the value.  `O(log_k(n))` where  `k` is the maximum number of childs per node in the tree,   and `n` is the maximum number of nodes ever appended.",
          "_key": "The key of the tree.",
          "_value": "The new value."
        }
      },
      "stakeOf(SortitionSumTreeFactory.SortitionSumTrees storage,bytes32,bytes32)": {
        "details": "Gets a specified ID's associated value.",
        "params": {
          "_ID": "The ID of the value.",
          "_key": "The key of the tree."
        },
        "returns": {
          "value": "The associated value."
        }
      }
    },
    "title": "SortitionSumTreeFactory",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}